// Определяем название пакета (модуля)
package main

// Импортируем библиотеки
import (
	"fmt"
	"math/rand"
	"time"
)

// Структура (в других языка Class) для хранения диапазона значений сложности
type Difficulty struct {
	Value1 int  # Минимальное значение
	Value2 int  # Максимальное значение
}

// Здесь начинается функция main которая в go является главной, без нее программа не запустится
func main() {
	// Это тип данных map, является аналогом словаря из других языков
	// По факту это просто ключ - значение. Ключ это число uint (не может быть отрицательным),
	// значение это класс Diffuculty (он чтобы в значение добавить 2 числа),
	// для этого есть и другой способ с вложенным словарем, но он не очень удобный
	m := map[uint]Difficulty{
		1: {0, 100},
		2: {0, 1000},
		3: {0, 10000},
		4: {-10000, 10000},
	}

	// Вывод сообщения приветствия
	fmt.Println("Приветствую вас в увлекательной игре — Угадай Число!")

	// Вывод уровней сложности, знак %d это элемент куда будет подставлено число (любое целое).
	// Числа подставляются из переменной m которая является словарем. 
	// Если возникает вопрос зачем это, если можно написать число прям здесь, ответ прост - 
	// если ты решишь внести изменения в уровни сложности, то ты будешь изменять только словарь,
	// а в остальной код лезть не придется. 
	fmt.Printf("Уровни сложности: \n"+
		"1) Легкий — от %d до %d\n"+
		"2) Нормальный — от %d до %d\n"+
		"3) Ненормальный — от %d до %d\n"+
		"4) Нереальный — от %d до %d\n",
		m[1].Value1, m[1].Value2,
		m[2].Value1, m[2].Value2,
		m[3].Value1, m[3].Value2,
		m[4].Value1, m[4].Value2,
	)


	// Активируем функцию diffucult и передаем ей словарь "m", значение которое
	// вернет функция записываем в переменную diff
	var diff = difficult(m)

	// Основная игровая функция, в нее мы передаем наш словарь (m), и сложность которую
	// выбрал пользователь во время работы функции difficult (diff)
	game(diff, m)
}

// Определяем фукнцию difficult которая принимает наш словарь со сложностями и
// возвращает переменную scandiff (сложность которую выбрал пользователь).
// Вообще главная идея этой функции определить сложность с которой хочет играть пользователь.
// Сложность которую ввел пользователь вернется из фукции в переменную diff
func difficult(diffmap map[uint]Difficulty) (scandiff uint) {
	diffcount := uint(len(diffmap))
	fmt.Println("\nВведите номер сложности: ")
	for {
		_, err := fmt.Scan(&scandiff)
		if err != nil || scandiff <= 0 || scandiff > diffcount {
			fmt.Printf("Введите номер сложности (от 1 до %d): ", diffcount)
			continue
		}
		break
	}
	return
}

// Определяем функцию game. Из этой функции активируются еще несколько функций
func game(diff uint, diffmap map[uint]Difficulty) {
	// Число которое будет вводить пользователь в попытке отгадать, будет записываться в эту переменную
	var guess int  
	
	// Здесь мы активируем фукнцию generateNumber, в которую передаем сложность (diff) и словарь сложностей
	// который называется в этой фукнции не "m", а diffmap. После завершения работы функции мы должны
	// получить в результаты ее работы в три переменные
	minNum, maxNum, randomNumber := generateNumber(diff, diffmap)

	// Активируем функцию которая выводит подсказку с диапазоном загаданного числа
	gameInfo(minNum, maxNum)


// Это метка цикла, с помощью нее можно начать игру заново
gameLoop:
	// Здесь начинается бесконечный цикл пока пользователь не отгадает число
	for {
		// Считываем введеное пользователем число
		_, err := fmt.Scan(&guess)

		// Проверяем его на ошибки (является ли оно вообще числом)
		if err != nil {
			fmt.Print("Вводите только числа! ")
			gameInfo(minNum, maxNum)
			continue
		}

		// Здесь проверям отгадал ли пользователь загадонное число (randomNumber).
		// Если он его отгадал выводится сообщение с подздравлением и 
		// срабатывает break, который заканчивает цикл for.
		switch {
		case guess < randomNumber:
			fmt.Println("Загаданное число больше")
		case guess > randomNumber:
			fmt.Println("Загаданное число меньше")
		case guess == randomNumber:
			fmt.Println("Поздравляю! Вы угадали!")
			break gameLoop
		}
	}
	
	// Этот бесконечный цикл for нужен после окончания игры, чтобы можно было сразу начать новую
	for {
		fmt.Println("\nХотите сыграть еще раз? (y/n)")
		var input string
		fmt.Scanln(&input)
		if input != "y" && input != "Y" && input != "yes" && input != "YES" {
			break
		}

		// Заново спрашиваем сложность
		diff = difficult(diffmap)
		
		// Генерируем новое число
		minNum, maxNum, randomNumber = generateNumber(diff, diffmap)
 		
		// Выводим подсказку с новым диапазоном
		gameInfo(minNum, maxNum)

		// Переходим по метке к циклу с новой игрой. По факту это конечная точка программы.
		goto gameLoop
	}
}

// Функция которая генерирует рандомное число, которое будет отгадывать пользователь
// Она получает сложность, и словарь сложностей, а возвращает минимальное число для генерации
// (minNum), максимальное число (maxNum) и рандомное число (randomNamber)
func generateNumber(diff uint, diffmap map[uint]Difficulty) (minNum, maxNum, randomNumber int) {
	// Определяем max и min числа, обращаясь к словарю сложностей с учетом выбранной пользователем сложности
	minNum = diffmap[diff].Value1
	maxNum = diffmap[diff].Value2

	// Инициализируем генератор случайных чисел
	rand.Seed(time.Now().UnixNano())

	// Генерируем случайное число в заданном диапазоне
	randomNumber = rand.Intn(maxNum-minNum) + minNum
	return
}

// Это информационная функция которая выводит подсказку о диапазоне загаданного числа
func gameInfo(minNum, maxNum int) {
	fmt.Printf("Угадайте число от %d до %d: \n", minNum, maxNum)
}
